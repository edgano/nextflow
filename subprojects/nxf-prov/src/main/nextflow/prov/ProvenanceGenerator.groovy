/*
 * Copyright (c) 2013-2018, Centre for Genomic Regulation (CRG).
 * Copyright (c) 2013-2018, Paolo Di Tommaso and the respective authors.
 *
 *   This file is part of 'Nextflow'.
 *
 *   Nextflow is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Nextflow is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Nextflow.  If not, see <http://www.gnu.org/licenses/>.
 */
package nextflow.prov

import groovy.transform.CompileStatic
import groovy.util.logging.Slf4j
import nextflow.trace.TraceRecord
import org.openprovenance.prov.interop.InteropFramework
import org.openprovenance.prov.model.*

import javax.xml.datatype.DatatypeFactory
import java.nio.file.Path
import java.nio.file.Paths
import java.security.MessageDigest

/**
 *
 * @author Edgar Garriga <edgano@gmail.com>
 */
@Slf4j
@CompileStatic
public class ProvenanceGenerator {
    /**
     * Enum to define the different types of the provenance
     */
    enum ProvenanceType {
        activityType, SHA256, fileSize, fileName, containerName
    }

    //** PROV info **
    public static final String PROVBOOK_NS = "prov";
    public static final String PROVBOOK_PREFIX = "PROV";

    private final String CHECKSUM_TYPE = "SHA-256"
    private final String provFileName = "provenance.json"
    private final String activity_prefix = "activity_"
    private final String used_prefix = "used_"
    private final String generatedBy_prefix = "generatedBy_"
    private final String agent_prefix="agent_"
    private final String associatedWith_prefix = "associatedWith_"

    private final ProvFactory pFactory = InteropFramework.newXMLProvFactory();
    private final Namespace ns;

    private Map<QualifiedName, Entity> inputEntityMap = new HashMap<QualifiedName, Entity>();
    //TODO Can merge both entity maps (I guess)
    private Map<QualifiedName, Entity> outputEntityMap = new HashMap<QualifiedName, Entity>();
    private Map<QualifiedName, Activity> activityMap = new HashMap<QualifiedName, Activity>();
    private Map<QualifiedName, Used> usedMap = new HashMap<QualifiedName, Used>();
    private Map<QualifiedName, WasGeneratedBy> generatedMap = new HashMap<QualifiedName, WasGeneratedBy>();
    private Map<QualifiedName, WasAssociatedWith> associatedMap = new HashMap<QualifiedName, WasAssociatedWith>();
    private Map<QualifiedName, Agent> agentMap = new HashMap<QualifiedName, Agent>();

    ProvenanceGenerator(){
        ns = new Namespace();
        ns.addKnownNamespaces();
        ns.register(PROVBOOK_PREFIX, PROVBOOK_NS);
    }

    /**
     * Convert String into a QualifiedName
     * @param n
     * @return QualifiedName
     */
    public QualifiedName qn(String n) {
        return ns.qualifiedName(PROVBOOK_PREFIX, n, pFactory);
    }

    /**
     * Get the provenance document
     * @return Document
     */
    public Document getProvDocument(){
        return pFactory.newDocument()
    }

    /**
     * Set all the provenance elements into the provDocument
     * @param provDocument
     */
    public void setElementsToProvFile(Document provDocument) {

        // Fill the PROV document with the inputs entities
        log.debug "Input Entity List: ${inputEntityMap.size()}"
        if (inputEntityMap.isEmpty()) {
            log.debug "Prov INPUT is empty"
        } else {
            for (Map.Entry<QualifiedName, Entity> entity : inputEntityMap.entrySet()) {
                provDocument.getStatementOrBundle().add(entity.value)
            }
        }

        // Fill the PROV document with the output entities
        log.debug "Output Entity List: ${outputEntityMap.size()}"
        if (outputEntityMap.isEmpty()) {
            log.debug "Prov OUTPUT is empty"
        } else {
            for (Map.Entry<QualifiedName, Entity> entity : outputEntityMap.entrySet()) {
                provDocument.getStatementOrBundle().add(entity.value)
            }
        }
        //ACTIVITY
        for (Map.Entry<QualifiedName, Activity> activity : activityMap.entrySet()) {
            provDocument.getStatementOrBundle().add(activity.value)
        }
        //USED
        for (Map.Entry<QualifiedName, Used> used : usedMap.entrySet()) {
            provDocument.getStatementOrBundle().add(used.value)
        }
        //WAS GENERATED BY
        for (Map.Entry<QualifiedName, WasGeneratedBy> generated : generatedMap.entrySet()) {
            provDocument.getStatementOrBundle().add(generated.value)
        }
        //ASSOCIATED WITH by
        for (Map.Entry<QualifiedName, WasAssociatedWith> associated : associatedMap.entrySet()) {
            provDocument.getStatementOrBundle().add(associated.value)
        }
        //AGENT
        for (Map.Entry<QualifiedName, Agent> agent : agentMap.entrySet()) {
            provDocument.getStatementOrBundle().add(agent.value)
        }
    }

    /**
     * Generate the provenance objects
     * @param trace
     */
    public generateProvenance(TraceRecord trace){

        Activity activity_object= generateActivities(trace)

        // Get the I/O objects from the trace.
        // Convert the string into a List<String> to iterate it
        def inputFiles = trace.getFmtStr("input")
        List<String> inputList = Arrays.asList(inputFiles.split(";"));

        def outputFiles = trace.getFmtStr("output")
        List<String> outputList = Arrays.asList(outputFiles.split(";"));

        generateInputEntity(trace, inputList, activity_object)

        generateOutputEntity(trace, outputList, activity_object)

        generateSoftwareAgent(trace,activity_object)
    }

    /**
     * Generate the prov Document using ProvToolBox
     * @param provDocument
     */
    public void generateProvFile(Document provDocument){
        provDocument.setNamespace(ns);
        InteropFramework intF=new InteropFramework();
        intF.writeDocument(provFileName, provDocument);
    }

    /**
     * Generate one activity for each NF process
     * @param trace
     * @return Activity
     */
    private Activity generateActivities(TraceRecord trace){

        String activityId = "${activity_prefix}${trace.getTaskId()}"
        Activity activity_object = pFactory.newActivity(qn(activityId.toString()));

        String typeAux = "Process"
        Object typeObj = typeAux
        pFactory.addType(activity_object, typeObj, qn(ProvenanceType.activityType.toString()))

        pFactory.addLabel(activity_object, trace.get("name").toString())

        setActivityTime(activity_object, trace)

        activityMap.put(activity_object.getId(), activity_object)

        return activity_object
    }

    /**
     * Add the time information into the Activity object
     * @param activity_object
     * @param trace
     */
    private void setActivityTime(Activity activity_object, TraceRecord trace){

        //convert miliseconds to Gregorain format
        final GregorianCalendar calendarGregStart = new GregorianCalendar();
        calendarGregStart.setTimeInMillis(trace.get("start") as long);
        def gregorianStart = DatatypeFactory.newInstance().newXMLGregorianCalendar(calendarGregStart);
        activity_object.setStartTime(gregorianStart)

        final GregorianCalendar calendarGregEnd = new GregorianCalendar();
        calendarGregEnd.setTimeInMillis(trace.get("complete") as long);
        def gregorianEnd = DatatypeFactory.newInstance().newXMLGregorianCalendar(calendarGregEnd);
        activity_object.setEndTime(gregorianEnd)
    }

    /**
     * Generate the Agent with the information:
     * script used
     * container name
     * container hash
     * container technology
     * @param trace
     * @param activity_object
     */
    private void generateSoftwareAgent(TraceRecord trace, Activity activity_object){
        String associatedWithId = "${associatedWith_prefix}${trace.getTaskId()}"
        String softwareId = "${agent_prefix}${activity_object.getId().localPart}"

        Agent softwareAgent = new org.openprovenance.prov.xml.Agent()
        softwareAgent.setId(qn(softwareId.toString()))
        pFactory.addLabel(softwareAgent, cleanScript(trace.get('script').toString()))
        pFactory.newAgent(softwareAgent)

        Object containerAux = trace.get('container').toString()
        pFactory.addType(softwareAgent, containerAux, qn(ProvenanceType.containerName.toString()))

        WasAssociatedWith associatedWith = pFactory.newWasAssociatedWith(qn(associatedWithId.toString()),activity_object.getId(),softwareAgent.getId()) //id, activity, agent

        associatedMap.put(associatedWith.getId(), associatedWith)
        agentMap.put(softwareAgent.getId(), softwareAgent)
    }

    /**
     * Generate the input entity
     * @param trace
     * @param inputList
     * @param activity_object
     */
    private void generateInputEntity(TraceRecord trace, List<String> inputList, Activity activity_object){

        for (elem in inputList) {
            Path pathAux = Paths.get(elem);
            String pathString = pathAux.toString().trim() //remove space from the begining of the path. need to avoid unexpected behaviour
            def entity_name = pathAux.getFileName()

            Entity input_entity = pFactory.newEntity(qn(pathString.toString()));

            input_entity.setValue(pFactory.newValue(entity_name.toString(), qn(ProvenanceType.fileName.toString())))

            File fileAux = new File(pathString)

            Object checkAux = getFileSHA256(fileAux)
            pFactory.addType(input_entity, checkAux, qn(ProvenanceType.SHA256.toString()))

            Object sizeAux = fileAux.length()
            pFactory.addType(input_entity, sizeAux, qn(ProvenanceType.fileSize.toString()))

            // Create the relation btwn the ACTIVITY and the ENTITY
            Used usedAction = pFactory.newUsed(activity_object.getId(), input_entity.getId());
            usedAction.setId(qn("${used_prefix}${trace.getTaskId()}_${pathString}"))
            usedMap.put(usedAction.getId(), usedAction)

            //Save the input element as an ENTITY inside the GLOBAL list of the Input entities
            inputEntityMap.put(input_entity.getId(), input_entity)
        }
    }

    /**
     * Generate the output entity
     * @param trace
     * @param outputList
     * @param activity_object
     */
    private void generateOutputEntity(TraceRecord trace, List<String> outputList, Activity activity_object){

        for (elem in outputList) {
            Path pathAux = Paths.get(elem);
            String pathString = pathAux.toString().trim() //remove space from the begining of the path. need to avoid unexpected behaviour
            def entity_name = pathAux.getFileName()

            Entity output_entity = pFactory.newEntity(qn(pathString.toString()));

            output_entity.setValue(pFactory.newValue(entity_name.toString(), qn(ProvenanceType.fileName.toString())))

            File fileAux = new File(pathString)
            Object checkAux = getFileSHA256(fileAux)
            pFactory.addType(output_entity, checkAux, qn(ProvenanceType.SHA256.toString()))

            Object sizeAux = fileAux.length()
            pFactory.addType(output_entity, sizeAux, qn(ProvenanceType.fileSize.toString()))

            //Create the relation btwn ACTIVITY and the ENTITY
            WasGeneratedBy generationAction = pFactory.newWasGeneratedBy(output_entity, "", activity_object)
            generationAction.setId(qn("${generatedBy_prefix}${trace.getTaskId()}_${pathString}"))
            generatedMap.put(generationAction.getId(), generationAction)

            //Save the input element as a ENTITY inside the GLOBAL list of the Input entities
            outputEntityMap.put(output_entity.getId(), output_entity)
        }
    }

    /**
     * Get the SHA256 from a file
     * @param fileAux
     * @return String with the SHA256
     */
    private String getFileSHA256(File fileAux ){
        //-- Digest sha256
        // https://gist.github.com/ikarius/299062/85b6540c99878f50f082aaee236ef15fc78e527c
        MessageDigest digest = MessageDigest.getInstance(CHECKSUM_TYPE);
        fileAux.withInputStream() { is ->
            byte[] buffer = new byte[8192]
            int read = 0
            while ((read = is.read(buffer)) > 0) {
                digest.update(buffer, 0, read);
            }
        }
        byte[] elementHash = digest.digest()
        return bytesToHex(elementHash)
    }

    /**
     * Convert from []bytes to Hex String
     * @param bytes
     * @return String with the sha code in hex
     */
    private String bytesToHex(byte[] bytes) {
        StringBuffer result = new StringBuffer();
        for (byte byt : bytes) result.append(Integer.toString((byt & 0xff) + 0x100, 16).substring(1));
        return result.toString();
    }

    /**
     * Clean the command line to include it as part of a label
     * @param script
     * @return String with the commandLine in one line
     */
    private String cleanScript(String script){
        return script.trim()
    }
}
